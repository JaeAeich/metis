syntax = "proto3";

package metel.v1;

import "google/protobuf/struct.proto";

option go_package = "github.com/jaeaeich/metis/internal/metel/proto";

// PluginExecution service defines RPCs for workflow execution.
service PluginExecution {
  // GetExecutionSpec provides the specification for executing a workflow.
  rpc GetExecutionSpec(GetExecutionSpecRequest) returns (ExecutionSpec);

  // ParseExecution parses the execution logs and returns a RunLog.
  rpc ParseExecution(ParseExecutionRequest) returns (WesRunLog);
}

message StagingInfo {
  // The type of staging service being used
  string type = 1;

  // The full URI to the remote staging area.
  // Example: s3://metis/workflows/wes_id
  string staging_uri = 2;

  // A map of parameters, including credentials, for accessing the object store.
  map<string, string> parameters = 3;
}

message LocalConfig {}

message TesConfig {
  string url = 1;
  string bearer_token = 2;
  string refresh_token = 3;
}

message BackendConfig {
  // Either local or tes
  string type = 1;
  TesConfig tes_config = 2;
  LocalConfig local_config = 3;
}

message GetExecutionSpecRequest {
  // The original WES request.
  WesRequest wes_request = 1;

  // The staging area information.
  StagingInfo staging_info = 2;

  // An optional argument which defines the entrypoint of the wf.
  // If metis is able to assume the entrypoint or the primary descriptor
  // then this value will be passed. Otherwise, it's the plugin's job to get the
  // descriptor file from the wes request or assume that based on a
  // standard or widely used practice, a default filename exists at the workDir
  // (for example, nextflow will assume main.nf, snakemake will assume Snakefile).
  // If the run fails, it's a user error. By assuming these files, the plugin can
  // generate the command, e.g., dummy-engine run dummyfile.
  // Example: file://./nesting/entrypoint.engine, file://entrypoint.engine
  string primary_descriptor = 3;

  // Backend configuration for execution
  BackendConfig backend_config = 4;
}

message WesRequest {
  string workflow_url = 1;
  string workflow_type = 2;
  string workflow_type_version = 3;
  map<string, google.protobuf.Value> workflow_params = 4;
  string workflow_engine = 5;
  string workflow_engine_version = 6;
  map<string, string> workflow_engine_parameters = 7;
  map<string, string> tags = 8;
}

message WesState {
  // The state of the task.
  State state = 1;
}

enum State {
  UNKNOWN = 0;
  QUEUED = 1;
  INITIALIZING = 2;
  RUNNING = 3;
  PAUSED = 4;
  COMPLETE = 5;
  EXECUTOR_ERROR = 6;
  SYSTEM_ERROR = 7;
  CANCELED = 8;
  CANCELING = 9;
  PREEMPTED = 10;
}

enum ParseState {
  UNKNOWN_STATE = 0;
  SUCCESS = 1;
  FAILURE = 2;
}

message Log {
  repeated string cmd = 1;
  string end_time = 2;
  int32 exit_code = 3;
  // If the name doesn't exists or the engine doesn't
  // parse it, then generate a random name.
  // Example: jumpy-mangoes
  string name = 4;
  string start_time = 5;
  string stderr = 6;
  string stdout = 7;
  // Plugin should return any logs it wants to, metis
  // will prepend its own system logs if need be.
  repeated string system_logs = 8;
}

message WesRunLog {
  State state = 1;
  Log run_log = 2;
  map<string, google.protobuf.Value> outputs = 3;
  repeated Log task_logs = 4;
}

message ParseExecutionRequest {
  // The logs from the workflow execution.
  string job_logs = 1;

  // The staging area so that plugin can list all the
  // wf files and parse a WES response out of them.
  StagingInfo staging_info = 2;

  // This helps the plugin to decide any log file generated
  // by the engine is to become stdout or err
  ParseState state = 3;
}

// ExecutionSpec contains the information needed to run the workflow.
message ExecutionSpec {
  // The container image to use for the workflow execution.
  string image = 1;

  // The command to run in the container.
  // Here the plugin should consume the WES request
  // and interpret what to run in the container where all
  // all the workflow files are present and that is the workDir of the
  // Pod.
  repeated string command = 2;

  // A map of file names to file content that should be mounted at the root
  // of the execution environment. This file will be made available to the Pod
  // at the root where.
  map<string, string> root_mount_files = 3;

  // A map of file names to file content that should be mounted in the project
  // directory of the execution environment. This files will be made available
  // at the project dir or where all the wf files are present and the
  // command is ran.
  map<string, string> project_mount_files = 4;

  // A map of environment variables to be set in the workflow container.
  map<string, string> environment = 5;

  // Local paths (directories or files) to be uploaded to the remote staging
  // area after workflow execution. The plugin can then parse these to extract
  // outputs and metadata for the WES response.
  // Example: .nextflow, .snakemake
  repeated string outputs_to_stage = 6;
}
