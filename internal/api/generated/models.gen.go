// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"encoding/json"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for State.
const (
	CANCELED      State = "CANCELED"
	CANCELING     State = "CANCELING"
	COMPLETE      State = "COMPLETE"
	EXECUTORERROR State = "EXECUTOR_ERROR"
	INITIALIZING  State = "INITIALIZING"
	PAUSED        State = "PAUSED"
	PREEMPTED     State = "PREEMPTED"
	QUEUED        State = "QUEUED"
	RUNNING       State = "RUNNING"
	SYSTEMERROR   State = "SYSTEM_ERROR"
	UNKNOWN       State = "UNKNOWN"
)

// DefaultWorkflowEngineParameter A message that allows one to describe default parameters for a workflow engine.
type DefaultWorkflowEngineParameter struct {
	// DefaultValue The stringified version of the default parameter. e.g. "2.45".
	DefaultValue *string `json:"default_value,omitempty"`

	// Name The name of the parameter
	Name *string `json:"name,omitempty"`

	// Type Describes the type of the parameter, e.g. float.
	Type *string `json:"type,omitempty"`
}

// ErrorResponse An object that can optionally include information about the error.
type ErrorResponse struct {
	// Msg A detailed error message.
	Msg *string `json:"msg,omitempty"`

	// StatusCode The integer representing the HTTP status code (e.g. 200, 404).
	StatusCode *int32 `json:"status_code,omitempty"`
}

// Log Log and other info
type Log struct {
	// Cmd The command line that was executed
	Cmd *[]string `json:"cmd,omitempty"`

	// EndTime When the command stopped executing (completed, failed, or cancelled), in ISO 8601 format "%Y-%m-%dT%H:%M:%SZ"
	EndTime *string `json:"end_time,omitempty"`

	// ExitCode Exit code of the program
	ExitCode *int32 `json:"exit_code,omitempty"`

	// Name The task or workflow name
	Name *string `json:"name,omitempty"`

	// StartTime When the command started executing, in ISO 8601 format "%Y-%m-%dT%H:%M:%SZ"
	StartTime *string `json:"start_time,omitempty"`

	// Stderr A URL to retrieve standard error logs of the workflow run or task.  This URL may change between status requests, or may not be available until the task or workflow has finished execution.  Should be available using the same credentials used to access the WES endpoint.
	Stderr *string `json:"stderr,omitempty"`

	// Stdout A URL to retrieve standard output logs of the workflow run or task.  This URL may change between status requests, or may not be available until the task or workflow has finished execution.  Should be available using the same credentials used to access the WES endpoint.
	Stdout *string `json:"stdout,omitempty"`

	// SystemLogs System logs are any logs the system decides are relevant,
	// which are not tied directly to a workflow.
	// Content is implementation specific: format, size, etc.
	//
	// System logs may be collected here to provide convenient access.
	//
	// For example, the system may include an error message that caused
	// a SYSTEM_ERROR state (e.g. disk is full), etc.
	SystemLogs *[]string `json:"system_logs,omitempty"`
}

// RunId defines model for RunId.
type RunId struct {
	// RunId workflow run ID
	RunId *string `json:"run_id,omitempty"`
}

// RunListResponse The service will return a RunListResponse when receiving a successful RunListRequest. DEPRECIATION WARNING: The use of `RunStatus` as the schema for `runs` array items will not be permitted from the next major version of the specification (2.0.0) onwards. We encourage implementers to use `RunSummary` instead.
type RunListResponse struct {
	// NextPageToken A token which may be supplied as `page_token` in workflow run list request to get the next page of results.  An empty string indicates there are no more items to return.
	NextPageToken *string `json:"next_page_token,omitempty"`

	// Runs A list of workflow runs that the service has executed or is executing. The list is filtered to only include runs that the caller has permission to see.
	Runs *[]RunListResponse_Runs_Item `json:"runs,omitempty"`
}

// RunListResponse_Runs_Item defines model for RunListResponse.runs.Item.
type RunListResponse_Runs_Item struct {
	union json.RawMessage
}

// RunLog defines model for RunLog.
type RunLog struct {
	// Outputs The outputs from the workflow run.
	Outputs *map[string]interface{} `json:"outputs,omitempty"`

	// Request To execute a workflow, send a run request including all the details needed to begin downloading
	// and executing a given workflow.
	// If workflow_engine and workflow_engine_version are not provided, servers can use the most recent workflow_engine_version of workflow_engine that WES instance uses to process the request if
	// supports for the requested workflow_type.
	Request *RunRequest `json:"request,omitempty"`

	// RunId workflow run ID
	RunId *string `json:"run_id,omitempty"`

	// RunLog Log and other info
	RunLog *Log `json:"run_log,omitempty"`

	// State State can take any of the following values:
	//
	//   + UNKNOWN: The state of the task is unknown. This provides a safe default for messages where this field is missing, for example, so that a missing field does not accidentally imply that the state is QUEUED.
	//
	//   + QUEUED: The task is queued.
	//
	//   + INITIALIZING: The task has been assigned to a worker and is currently preparing to run. For example, the worker may be turning on, downloading input files, etc.
	//
	//   + RUNNING: The task is running. Input files are downloaded and the first Executor has been started.
	//
	//   + PAUSED: The task is paused. An implementation may have the ability to pause a task, but this is not required.
	//
	//   + COMPLETE: The task has completed running. Executors have exited without error
	//   and output files have been successfully uploaded.
	//
	//   + EXECUTOR_ERROR: The task encountered an error in one of the Executor processes. Generally,
	// this means that an Executor exited with a non-zero exit code.
	//
	//   + SYSTEM_ERROR: The task was stopped due to a system error, but not from an Executor,
	// for example an upload failed due to network issues, the worker's ran out of disk space, etc.
	//
	//   + CANCELED: The task was canceled by the user.
	//
	//   + CANCELING: The task was canceled by the user, and is in the process of stopping.
	//
	//   + PREEMPTED: The task is stopped (preempted) by the system. The reasons for this would be tied to
	// the specific system running the job. Generally, this means that the system reclaimed the compute capacity for reallocation.
	State *State `json:"state,omitempty"`

	// TaskLogs The logs, and other key info like timing and exit code, for each step in the workflow run. This field is deprecated and the `task_logs_url` should be used to retrieve a paginated list of steps from the workflow run. This field will be removed in the next major version of the specification (2.0.0)
	// Deprecated:
	TaskLogs *[]RunLog_TaskLogs_Item `json:"task_logs"`

	// TaskLogsUrl A reference to the complete url which may be used to obtain a paginated list of task logs for this workflow
	TaskLogsUrl *string `json:"task_logs_url,omitempty"`
}

// RunLog_TaskLogs_Item defines model for RunLog.task_logs.Item.
type RunLog_TaskLogs_Item struct {
	union json.RawMessage
}

// RunRequest To execute a workflow, send a run request including all the details needed to begin downloading
// and executing a given workflow.
// If workflow_engine and workflow_engine_version are not provided, servers can use the most recent workflow_engine_version of workflow_engine that WES instance uses to process the request if
// supports for the requested workflow_type.
type RunRequest struct {
	Tags *map[string]string `json:"tags,omitempty"`

	// WorkflowEngine The workflow engine, must be one supported by this WES instance. Required if workflow_engine_version is provided.
	WorkflowEngine           *string            `json:"workflow_engine,omitempty"`
	WorkflowEngineParameters *map[string]string `json:"workflow_engine_parameters,omitempty"`

	// WorkflowEngineVersion The workflow engine version, must be one supported by this WES instance. If workflow_engine is provided, but workflow_engine_version is not, servers can make no assumptions with regard to the engine version the WES instance uses to process the request if that WES instance supports multiple versions of the requested engine.
	WorkflowEngineVersion *string `json:"workflow_engine_version,omitempty"`

	// WorkflowParams REQUIRED
	// The workflow run parameterizations (JSON encoded), including input and output file locations
	WorkflowParams *map[string]interface{} `json:"workflow_params,omitempty"`

	// WorkflowType REQUIRED
	// The workflow descriptor type, must be "CWL" or "WDL" currently (or another alternative supported by this WES instance)
	WorkflowType string `json:"workflow_type"`

	// WorkflowTypeVersion REQUIRED
	// The workflow descriptor type version, must be one supported by this WES instance
	WorkflowTypeVersion string `json:"workflow_type_version"`

	// WorkflowUrl REQUIRED
	// The workflow CWL or WDL document. When `workflow_attachments` is used to attach files, the `workflow_url` may be a relative path to one of the attachments.
	WorkflowUrl string `json:"workflow_url"`
}

// RunStatus State information of a workflow run
type RunStatus struct {
	RunId string `json:"run_id"`

	// State State can take any of the following values:
	//
	//   + UNKNOWN: The state of the task is unknown. This provides a safe default for messages where this field is missing, for example, so that a missing field does not accidentally imply that the state is QUEUED.
	//
	//   + QUEUED: The task is queued.
	//
	//   + INITIALIZING: The task has been assigned to a worker and is currently preparing to run. For example, the worker may be turning on, downloading input files, etc.
	//
	//   + RUNNING: The task is running. Input files are downloaded and the first Executor has been started.
	//
	//   + PAUSED: The task is paused. An implementation may have the ability to pause a task, but this is not required.
	//
	//   + COMPLETE: The task has completed running. Executors have exited without error
	//   and output files have been successfully uploaded.
	//
	//   + EXECUTOR_ERROR: The task encountered an error in one of the Executor processes. Generally,
	// this means that an Executor exited with a non-zero exit code.
	//
	//   + SYSTEM_ERROR: The task was stopped due to a system error, but not from an Executor,
	// for example an upload failed due to network issues, the worker's ran out of disk space, etc.
	//
	//   + CANCELED: The task was canceled by the user.
	//
	//   + CANCELING: The task was canceled by the user, and is in the process of stopping.
	//
	//   + PREEMPTED: The task is stopped (preempted) by the system. The reasons for this would be tied to
	// the specific system running the job. Generally, this means that the system reclaimed the compute capacity for reallocation.
	State *State `json:"state,omitempty"`
}

// RunSummary defines model for RunSummary.
type RunSummary struct {
	// EndTime When the run stopped executing (completed, failed, or cancelled), in ISO 8601 format "%Y-%m-%dT%H:%M:%SZ"
	EndTime *string `json:"end_time,omitempty"`
	RunId   string  `json:"run_id"`

	// StartTime When the run started executing, in ISO 8601 format "%Y-%m-%dT%H:%M:%SZ"
	StartTime *string `json:"start_time,omitempty"`

	// State State can take any of the following values:
	//
	//   + UNKNOWN: The state of the task is unknown. This provides a safe default for messages where this field is missing, for example, so that a missing field does not accidentally imply that the state is QUEUED.
	//
	//   + QUEUED: The task is queued.
	//
	//   + INITIALIZING: The task has been assigned to a worker and is currently preparing to run. For example, the worker may be turning on, downloading input files, etc.
	//
	//   + RUNNING: The task is running. Input files are downloaded and the first Executor has been started.
	//
	//   + PAUSED: The task is paused. An implementation may have the ability to pause a task, but this is not required.
	//
	//   + COMPLETE: The task has completed running. Executors have exited without error
	//   and output files have been successfully uploaded.
	//
	//   + EXECUTOR_ERROR: The task encountered an error in one of the Executor processes. Generally,
	// this means that an Executor exited with a non-zero exit code.
	//
	//   + SYSTEM_ERROR: The task was stopped due to a system error, but not from an Executor,
	// for example an upload failed due to network issues, the worker's ran out of disk space, etc.
	//
	//   + CANCELED: The task was canceled by the user.
	//
	//   + CANCELING: The task was canceled by the user, and is in the process of stopping.
	//
	//   + PREEMPTED: The task is stopped (preempted) by the system. The reasons for this would be tied to
	// the specific system running the job. Generally, this means that the system reclaimed the compute capacity for reallocation.
	State *State `json:"state,omitempty"`

	// Tags Arbitrary key/value tags added by the client during run creation
	Tags map[string]string `json:"tags"`
}

// Service GA4GH service
type Service struct {
	// ContactUrl URL of the contact for the provider of this service, e.g. a link to a contact form (RFC 3986 format), or an email (RFC 2368 format).
	ContactUrl *string `json:"contactUrl,omitempty"`

	// CreatedAt Timestamp describing when the service was first deployed and available (RFC 3339 format)
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Description Description of the service. Should be human readable and provide information about the service.
	Description *string `json:"description,omitempty"`

	// DocumentationUrl URL of the documentation of this service (RFC 3986 format). This should help someone learn how to use your service, including any specifics required to access data, e.g. authentication.
	DocumentationUrl *string `json:"documentationUrl,omitempty"`

	// Environment Environment the service is running in. Use this to distinguish between production, development and testing/staging deployments. Suggested values are prod, test, dev, staging. However this is advised and not enforced.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID of this service. Reverse domain name notation is recommended, though not required. The identifier should attempt to be globally unique so it can be used in downstream aggregator services e.g. Service Registry.
	Id string `json:"id"`

	// Name Name of this service. Should be human readable.
	Name string `json:"name"`

	// Organization Organization providing the service
	Organization struct {
		// Name Name of the organization responsible for the service
		Name string `json:"name"`

		// Url URL of the website of the organization (RFC 3986 format)
		Url string `json:"url"`
	} `json:"organization"`

	// Type Type of a GA4GH service
	Type ServiceType `json:"type"`

	// UpdatedAt Timestamp describing when the service was last updated (RFC 3339 format)
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Version Version of the service being described. Semantic versioning is recommended, but other identifiers, such as dates or commit hashes, are also allowed. The version should be changed whenever the service is updated.
	Version string `json:"version"`
}

// ServiceInfo defines model for ServiceInfo.
type ServiceInfo struct {
	// AuthInstructionsUrl A web page URL with human-readable instructions on how to get an authorization token for use with a specific WES endpoint.
	AuthInstructionsUrl string `json:"auth_instructions_url"`

	// ContactUrl URL of the contact for the provider of this service, e.g. a link to a contact form (RFC 3986 format), or an email (RFC 2368 format).
	ContactUrl *string `json:"contactUrl,omitempty"`

	// CreatedAt Timestamp describing when the service was first deployed and available (RFC 3339 format)
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// DefaultWorkflowEngineParameters Each workflow engine can present additional parameters that can be sent to the workflow engine. This message will list the default values, and their types for each workflow engine.
	DefaultWorkflowEngineParameters []DefaultWorkflowEngineParameter `json:"default_workflow_engine_parameters"`

	// Description Description of the service. Should be human readable and provide information about the service.
	Description *string `json:"description,omitempty"`

	// DocumentationUrl URL of the documentation of this service (RFC 3986 format). This should help someone learn how to use your service, including any specifics required to access data, e.g. authentication.
	DocumentationUrl *string `json:"documentationUrl,omitempty"`

	// Environment Environment the service is running in. Use this to distinguish between production, development and testing/staging deployments. Suggested values are prod, test, dev, staging. However this is advised and not enforced.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID of this service. Reverse domain name notation is recommended, though not required. The identifier should attempt to be globally unique so it can be used in downstream aggregator services e.g. Service Registry.
	Id string `json:"id"`

	// Name Name of this service. Should be human readable.
	Name string `json:"name"`

	// Organization Organization providing the service
	Organization struct {
		// Name Name of the organization responsible for the service
		Name string `json:"name"`

		// Url URL of the website of the organization (RFC 3986 format)
		Url string `json:"url"`
	} `json:"organization"`

	// SupportedFilesystemProtocols The filesystem protocols supported by this service, currently these may include common protocols using the terms 'http', 'https', 'sftp', 's3', 'gs', 'file', or 'synapse', but others  are possible and the terms beyond these core protocols are currently not fixed.   This section reports those protocols (either common or not) supported by this WES service.
	SupportedFilesystemProtocols []string `json:"supported_filesystem_protocols"`

	// SupportedWesVersions The version(s) of the WES schema supported by this service
	SupportedWesVersions []string          `json:"supported_wes_versions"`
	SystemStateCounts    map[string]int64  `json:"system_state_counts"`
	Tags                 map[string]string `json:"tags"`

	// Type Type of a GA4GH service
	Type ServiceType `json:"type"`

	// UpdatedAt Timestamp describing when the service was last updated (RFC 3339 format)
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Version Version of the service being described. Semantic versioning is recommended, but other identifiers, such as dates or commit hashes, are also allowed. The version should be changed whenever the service is updated.
	Version                string                           `json:"version"`
	WorkflowEngineVersions map[string]WorkflowEngineVersion `json:"workflow_engine_versions"`
	WorkflowTypeVersions   map[string]WorkflowTypeVersion   `json:"workflow_type_versions"`
}

// ServiceType Type of a GA4GH service
type ServiceType struct {
	// Artifact Name of the API or GA4GH specification implemented. Official GA4GH types should be assigned as part of standards approval process. Custom artifacts are supported.
	Artifact string `json:"artifact"`

	// Group Namespace in reverse domain name format. Use `org.ga4gh` for implementations compliant with official GA4GH specifications. For services with custom APIs not standardized by GA4GH, or implementations diverging from official GA4GH specifications, use a different namespace (e.g. your organization's reverse domain name).
	Group string `json:"group"`

	// Version Version of the API or specification. GA4GH specifications use semantic versioning.
	Version string `json:"version"`
}

// State State can take any of the following values:
//
//   - UNKNOWN: The state of the task is unknown. This provides a safe default for messages where this field is missing, for example, so that a missing field does not accidentally imply that the state is QUEUED.
//
//   - QUEUED: The task is queued.
//
//   - INITIALIZING: The task has been assigned to a worker and is currently preparing to run. For example, the worker may be turning on, downloading input files, etc.
//
//   - RUNNING: The task is running. Input files are downloaded and the first Executor has been started.
//
//   - PAUSED: The task is paused. An implementation may have the ability to pause a task, but this is not required.
//
//   - COMPLETE: The task has completed running. Executors have exited without error
//     and output files have been successfully uploaded.
//
//   - EXECUTOR_ERROR: The task encountered an error in one of the Executor processes. Generally,
//
// this means that an Executor exited with a non-zero exit code.
//
//   - SYSTEM_ERROR: The task was stopped due to a system error, but not from an Executor,
//
// for example an upload failed due to network issues, the worker's ran out of disk space, etc.
//
//   - CANCELED: The task was canceled by the user.
//
//   - CANCELING: The task was canceled by the user, and is in the process of stopping.
//
//   - PREEMPTED: The task is stopped (preempted) by the system. The reasons for this would be tied to
//
// the specific system running the job. Generally, this means that the system reclaimed the compute capacity for reallocation.
type State string

// TaskListResponse The service will return a TaskListResponse when receiving a successful TaskListRequest.
type TaskListResponse struct {
	// NextPageToken A token which may be supplied as `page_token` in workflow run task list request to get the next page of results.  An empty string indicates there are no more items to return.
	NextPageToken *string `json:"next_page_token,omitempty"`

	// TaskLogs The logs, and other key info like timing and exit code, for each step in the workflow run.
	TaskLogs *[]TaskLog `json:"task_logs,omitempty"`
}

// TaskLog defines model for TaskLog.
type TaskLog struct {
	// Cmd The command line that was executed
	Cmd *[]string `json:"cmd,omitempty"`

	// EndTime When the command stopped executing (completed, failed, or cancelled), in ISO 8601 format "%Y-%m-%dT%H:%M:%SZ"
	EndTime *string `json:"end_time,omitempty"`

	// ExitCode Exit code of the program
	ExitCode *int32 `json:"exit_code,omitempty"`

	// Id A unique identifier which may be used to reference the task
	Id *string `json:"id,omitempty"`

	// Name The task or workflow name
	Name *string `json:"name,omitempty"`

	// StartTime When the command started executing, in ISO 8601 format "%Y-%m-%dT%H:%M:%SZ"
	StartTime *string `json:"start_time,omitempty"`

	// Stderr A URL to retrieve standard error logs of the workflow run or task.  This URL may change between status requests, or may not be available until the task or workflow has finished execution.  Should be available using the same credentials used to access the WES endpoint.
	Stderr *string `json:"stderr,omitempty"`

	// Stdout A URL to retrieve standard output logs of the workflow run or task.  This URL may change between status requests, or may not be available until the task or workflow has finished execution.  Should be available using the same credentials used to access the WES endpoint.
	Stdout *string `json:"stdout,omitempty"`

	// SystemLogs System logs are any logs the system decides are relevant,
	// which are not tied directly to a task.
	// Content is implementation specific: format, size, etc.
	//
	// System logs may be collected here to provide convenient access.
	//
	// For example, the system may include the name of the host
	// where the task is executing, an error message that caused
	// a SYSTEM_ERROR state (e.g. disk is full), etc.
	SystemLogs *[]string `json:"system_logs,omitempty"`

	// TesUri An optional URL pointing to an extended task definition defined by a [TES api](https://github.com/ga4gh/task-execution-schemas)
	TesUri *string `json:"tes_uri,omitempty"`
}

// WorkflowEngineVersion Available workflow engine versions supported by a given instance of the service.
type WorkflowEngineVersion struct {
	// WorkflowEngineVersion An array of one or more acceptable engines versions for the `workflow_engine`
	WorkflowEngineVersion *[]string `json:"workflow_engine_version,omitempty"`
}

// WorkflowTypeVersion Available workflow types supported by a given instance of the service.
type WorkflowTypeVersion struct {
	// WorkflowTypeVersion an array of one or more acceptable types for the `workflow_type`
	WorkflowTypeVersion *[]string `json:"workflow_type_version,omitempty"`
}

// ListRunsParams defines parameters for ListRuns.
type ListRunsParams struct {
	// PageSize OPTIONAL The preferred number of workflow runs to return in a page. If not provided, the implementation should use a default page size. The implementation must not return more items than `page_size`, but it may return fewer.  Clients should not assume that if fewer than `page_size` items are returned that all items have been returned.  The availability of additional pages is indicated by the value of `next_page_token` in the response.
	PageSize *int64 `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken OPTIONAL Token to use to indicate where to start getting results. If unspecified, return the first page of results.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// RunWorkflowMultipartBody defines parameters for RunWorkflow.
type RunWorkflowMultipartBody struct {
	Tags                     *string               `json:"tags,omitempty"`
	WorkflowAttachment       *[]openapi_types.File `json:"workflow_attachment,omitempty"`
	WorkflowEngine           *string               `json:"workflow_engine,omitempty"`
	WorkflowEngineParameters *string               `json:"workflow_engine_parameters,omitempty"`
	WorkflowEngineVersion    *string               `json:"workflow_engine_version,omitempty"`
	WorkflowParams           *string               `json:"workflow_params,omitempty"`
	WorkflowType             *string               `json:"workflow_type,omitempty"`
	WorkflowTypeVersion      *string               `json:"workflow_type_version,omitempty"`
	WorkflowUrl              *string               `json:"workflow_url,omitempty"`
}

// ListTasksParams defines parameters for ListTasks.
type ListTasksParams struct {
	// PageSize OPTIONAL The preferred number of task logs to return in a page. If not provided, the implementation should use a default page size. The implementation must not return more items than `page_size`, but it may return fewer.  Clients should not assume that if fewer than `page_size` items are returned that all items have been returned.  The availability of additional pages is indicated by the value of `next_page_token` in the response.
	PageSize *int64 `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken OPTIONAL Token to use to indicate where to start getting results. If unspecified, return the first page of results.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// RunWorkflowMultipartRequestBody defines body for RunWorkflow for multipart/form-data ContentType.
type RunWorkflowMultipartRequestBody RunWorkflowMultipartBody

// AsRunStatus returns the union data inside the RunListResponse_Runs_Item as a RunStatus
func (t RunListResponse_Runs_Item) AsRunStatus() (RunStatus, error) {
	var body RunStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunStatus overwrites any union data inside the RunListResponse_Runs_Item as the provided RunStatus
func (t *RunListResponse_Runs_Item) FromRunStatus(v RunStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunStatus performs a merge with any union data inside the RunListResponse_Runs_Item, using the provided RunStatus
func (t *RunListResponse_Runs_Item) MergeRunStatus(v RunStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunSummary returns the union data inside the RunListResponse_Runs_Item as a RunSummary
func (t RunListResponse_Runs_Item) AsRunSummary() (RunSummary, error) {
	var body RunSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunSummary overwrites any union data inside the RunListResponse_Runs_Item as the provided RunSummary
func (t *RunListResponse_Runs_Item) FromRunSummary(v RunSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunSummary performs a merge with any union data inside the RunListResponse_Runs_Item, using the provided RunSummary
func (t *RunListResponse_Runs_Item) MergeRunSummary(v RunSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RunListResponse_Runs_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RunListResponse_Runs_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLog returns the union data inside the RunLog_TaskLogs_Item as a Log
func (t RunLog_TaskLogs_Item) AsLog() (Log, error) {
	var body Log
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLog overwrites any union data inside the RunLog_TaskLogs_Item as the provided Log
func (t *RunLog_TaskLogs_Item) FromLog(v Log) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLog performs a merge with any union data inside the RunLog_TaskLogs_Item, using the provided Log
func (t *RunLog_TaskLogs_Item) MergeLog(v Log) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTaskLog returns the union data inside the RunLog_TaskLogs_Item as a TaskLog
func (t RunLog_TaskLogs_Item) AsTaskLog() (TaskLog, error) {
	var body TaskLog
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTaskLog overwrites any union data inside the RunLog_TaskLogs_Item as the provided TaskLog
func (t *RunLog_TaskLogs_Item) FromTaskLog(v TaskLog) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTaskLog performs a merge with any union data inside the RunLog_TaskLogs_Item, using the provided TaskLog
func (t *RunLog_TaskLogs_Item) MergeTaskLog(v TaskLog) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RunLog_TaskLogs_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RunLog_TaskLogs_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
